---
title: "Introduction to local linear forests"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{llf}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(123)
```

```{r setup, warning = FALSE, message = FALSE}
library(grf)
library(glmnet)
library(ggplot2)
library(reshape2)
```

This document aims to show how to use local linear forests (LLF). We begin with the standard use case, walking through parameter choices and method details, and then discuss how to use local linear corrections with larger datasets. 

## Local Linear Forests: the basics

Random forests are a popular and powerful nonparametric regression method, but can suffer in the presence of strong, smooth effects. Local linear regression is a great method for fitting relatively smooth functions in low dimensions, but quickly deteriorates due to the curse of dimensionality: it relies on Euclidean distance, which fast loses its locality even in 4 or 5 dimensions. This algorithm leverages the strengths of each method (the data adaptivity of random forests and smooth fits of local linear regression) to give improved predictions and confidence intervals. For a complete treatment of local linear forests (LLF), see \texttt{https://arxiv.org/abs/1807.11408}. 

Consider a random forest with $B$ trees predicting at a test point $x_0$. In each tree $b$, the test point falls into a leaf $L_b(x_0)$. A regression forest predicts by averaging all responses in $L_b(x_0)$, and then averaging those predictions $\hat{\mu}_b(x_0)$ over all trees. To gain a new perspective on random forests, we can swap the sum to start thinking about random forests as a kernel or weighting method in high dimensions.

\begin{align*}
\hat{\mu}(x_0) 
&= \frac1B \sum_{b=1}^B \sum_{i=1}^n Y_i \frac{1\{x_i\in L_b(x_0)\}}{|L_b(x_0)|}\\
&= \sum_{i=1}^n Y_i \frac1B \sum_{b=1}^B \frac{1\{x_i\in L_b(x_0)\}}{|L_b(x_0)|} \\
&= \sum_{i=1}^n \alpha_i(x_0) Y_i,
\end{align*}
where the forest weight is
\begin{equation}
\alpha_i(x_0) = \frac1B \sum_{b=1}^B \frac{1\{x_i\in L_b(x_0)\}}{|L_b(x_0)|}
\end{equation}

Local linear forests take this one step further: now, instead of using the weights to fit a local average at $x_0$, we use them to fit a local linear regression, with a ridge penalty for regularization. This amounts to solving the minimization problem below, with parameters: $\mu(x)$ for the local average, and $\theta(x)$ for the slope of the local line.
\begin{equation}
\begin{pmatrix} \hat{\mu}(x_0) \\ \hat{\theta}(x_0) \end{pmatrix} = \text{argmin}_{\mu,\theta} \left\{\sum_{i=1}^n \alpha_i(x_0) (Y_i - \mu(x_0) - (x_i - x_0)\theta(x_0) )^2 + \lambda ||\theta(x_0)||_2^2\right\}.
\end{equation}

This enables us to (i) use local linear regression in high dimensions with a meaningful kernel, and (ii) predict with random forests even in the presence of smooth, strong signals. 

## Training the Algorithm

```{r}
n <- 600
p <- 20
sigma <- sqrt(20)

mu <- function( x ) {
  10 * sin(pi * x[1] * x[2]) + 20 * ((x[3] - 0.5) ** 2) + 10 * x[4] + 5 * x[5]
}

X <- matrix(runif(n*p, 0, 1), nrow = n)
Y <- apply(X, FUN = mu, MARGIN = 1) + sigma * rnorm(n)

X.test <- matrix(runif(n*p, 0, 1), nrow = n)
truth = apply(X.test, FUN = mu, MARGIN = 1)

# regression forest predictions
rforest <- regression_forest(X, Y, honesty = TRUE)
results <- predict(rforest, X.test) 
preds <- results$predictions
mean((preds - truth)**2)
```

We can get LLF predictions both from a standard regression forest by specifying linear correction variables, or from a ll_regression_forest object. The parameter linear correction variables gives the variables to use for the final local regression step. This can simply be all variables, or might be a subset. 

```{r}
# llf predictions from regression_forest
results.llf <- predict(rforest, X.test, linear.correction.variables = 1:p) 
preds.llf <- results.llf$predictions
mean((preds.llf - truth)**2)

# llf predictions from ll_regression_forest
forest <- ll_regression_forest(X, Y, honesty = TRUE)
results.llf <- predict(forest, X.test) 
preds.llf <- results.llf$predictions
mean((preds.llf - truth)**2)
```

When we perform LLF predictions, we can either do a standard ridge regression (ll.weight.penalty set to FALSE), or scale by the covariance matrix (ll.weight.penalty set to TRUE). This defaults to FALSE.

```{r}
results.llf.weighted <- predict(forest, X.test, 
                               ll.weight.penalty = TRUE) 
preds.llf.weighted <- results.llf.weighted$predictions
mean((preds.llf.weighted - truth)**2)
```

The user can choose to specify a ridge regression parameter ll.lambda. When this variable is not set by the user, it will be selected by automatic parameter tuning. In general, we recommend letting the forest tune this parameter, or performing your own cross-validation loop. The exception to this would be for very large datasets. 

```{r}
results.llf.lambda <- predict(forest, X.test, 
                             ll.lambda = 0.1) 
preds.llf.lambda <- results.llf.lambda$predictions
mean((preds.llf.lambda - truth)**2)
```

## Residual Splits

We also consider the role of tree training in local linear forests. A standard CART split minimizes prediction error from predicting leaf-wide averages. Instead, we can use residual splits, which minimize the corresponding prediction errors on ridge regression residuals. We might expect this to help in cases where there are strong linear signals from some covariates; we won't waste any forest splits modelling those, but can still discover them in the final regression step. Essentially this helps us make the most efficient possible splits in the forest, knowing that we have a local regression coming up to predict. This is currently an experimental feature.  

```{r}
forest <- ll_regression_forest(X, Y)
preds.cart.splits <- predict(forest, X.test)

ll.forest <- ll_regression_forest(X, Y, enable.ll.split = TRUE,
                                   ll.split.weight.penalty = TRUE)
preds.ll.splits <- predict(ll.forest, X.test)

mse.cart.splits <- mean((preds.cart.splits$predictions - truth)^2)
mse.ll.splits <- mean((preds.ll.splits$predictions - truth)^2)

mse.cart.splits
mse.ll.splits
```

To uncover exactly why this works, we can look at plots showing the split frequencies of both forests. In each plot, tiles represent how many splits at at given level (y-axis) of the tree were at each feature (x-axis). 

```{r, message = FALSE}
p <- 5
XX <- matrix(runif(n * p, 0 ,1), nrow = n)
YY <- apply(XX, MARGIN = 1, FUN = mu) + sigma * rnorm(n)

forest <- regression_forest(XX, YY)

max.depth <- 4
freqs <- split_frequencies(forest, max.depth = max.depth)
d <- data.frame(freqs)
dm <- melt(d)
dm$depth <- rep(1:max.depth, p)

# normalize value by sum of value at depth
for(i in 1:max.depth){
  tot.depth <- sum(dm[dm$depth == i,]$value)
  dm[dm$depth == i,]$value <- dm[dm$depth == i,]$value / tot.depth
}

g<- ggplot(dm, aes(x = variable, y = -depth, fill = value)) + 
  geom_tile() + 
  xlab("Variable") + 
  ylab("Depth") + 
  scale_fill_gradient(low = "white", high = "blue",limits = c(0,1), "Frequency \n") + 
  ggtitle("") + 
  theme(text = element_text(size = 15))
g
```

```{r, message = FALSE}
forest <- ll_regression_forest(XX, YY, enable.ll.split = TRUE,
                              ll.split.weight.penalty = TRUE) 

freqs <- split_frequencies(forest, max.depth = max.depth)
d <- data.frame(freqs)
dm <- melt(d)
dm$depth <- rep(1:max.depth,p)

for(i in 1:max.depth){
  tot.depth <- sum(dm[dm$depth == i,]$value)
  dm[dm$depth == i,]$value <- dm[dm$depth == i,]$value / tot.depth
}

g2 <- ggplot(dm, aes(x=variable, y=-depth, fill = value)) + 
  geom_tile() + 
  xlab("Variable") + 
  ylab("Depth") + 
  scale_fill_gradient(low = "white", high = "blue", limits = c(0,1), "Frequency \n") + 
  ggtitle("Split Frequencies: LLF") + 
  theme(text = element_text(size = 15))
g2
```

## Linear Correction Variable Selection

Especially with many covariates, it is reasonable to restrict the local regression to only include a few features of interest. We recommend using the lasso. 

```{r}
# Train forest
forest <- ll_regression_forest(X, Y)

# Select covariates 
lasso.mod <- cv.glmnet(X, Y, alpha = 1)
lasso.coef <- predict(lasso.mod, type = "nonzero")
selected <- lasso.coef[,1]
selected

# Predict with all covariates
llf.all.preds <- predict(forest, X.test)
results.all <- llf.all.preds$predictions
mean((results.all - truth)**2)

# Predict with just those covariates
llf.lasso.preds <- predict(forest, X.test, 
                           linear.correction.variables = selected)
results.llf.lasso <- llf.lasso.preds$predictions
mean((results.llf.lasso - truth)**2)
```

## Pointwise Confidence Intervals

Last, consider variance estimates and confidence intervals, which are analogous to grf variance estimates. We use a different data-generating process for easier visualization.

```{r}
mu <- function(x){ log(1 + exp(6 * x)) }

p <- 20

X <- matrix(runif(n*p, -1, 1), nrow = n)
Y <- mu(X[,1]) + sigma * rnorm(n)

X.test <- matrix(runif(n*p, -1, 1), nrow = n)
ticks <- seq(-1, 1, length = n)
X.test[,1] <- ticks
truth <- mu(ticks)

ll.forest <- ll_regression_forest(X, Y, enable.ll.split = TRUE)
results.llf.var <- predict(ll.forest, X.test, 
                           linear.correction.variables = selected, 
                          estimate.variance = TRUE)
preds.llf.var <- results.llf.var$predictions
variance.estimates <- results.llf.var$variance.estimates

# find lower and upper bounds for 95% intervals 
lower.llf <- preds.llf.var - 1.96*sqrt(variance.estimates)
upper.llf <- preds.llf.var + 1.96*sqrt(variance.estimates)

df <- data.frame(cbind(ticks, truth, preds.llf.var, lower.llf, upper.llf))
ggplot(df, aes(ticks)) + 
  geom_point(aes(y = preds.llf.var, color = "Local Linear Forest"), show.legend = F, size = 0.6) +
  geom_line(aes(y = truth)) + 
  geom_line(aes(y = lower.llf), color = "gray", lty = 2) + 
  geom_line(aes(y = upper.llf), color = "gray", lty = 2) + 
  xlab("x") + ylab("y") + theme_bw()
```

## A note on Larger Datasets

Local linear forests work well in low dimensions; when we get more data, however, it starts to take a very long time to run. This is because with n_train and n_test train and test points, we are running n_test regressions with n_train data points each. However, sometimes we still want to use random forests and correct for linear trends. In this case (datasets with roughly 100,000 or more observations, although always context-dependent), selecting a small number linear correction variables is especially important. The current ridge parameter tuning will also take prohibitively long, and so we recommend either setting the value to 0.01 consistently, tuning this on a subset of the data, restricting the range of values considered, or cross-validating using a small number of shallow trees.  
